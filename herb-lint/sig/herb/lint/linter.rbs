# Generated from lib/herb/lint/linter.rb with RBS::Inline

module Herb
  module Lint
    # Linter processes a single file and returns lint results.
    # It applies a set of rules to a parsed document and collects offenses.
    class Linter
      attr_reader rules: Array[Rules::Base | Rules::VisitorRule]

      attr_reader config: Herb::Config::LinterConfig

      attr_reader rule_registry: RuleRegistry

      attr_reader ignore_disable_comments: bool

      # @rbs config: Herb::Config::LinterConfig
      # @rbs rule_registry: RuleRegistry -- registry for rule lookup and instantiation
      # @rbs ignore_disable_comments: bool -- when true, report offenses even when suppressed
      def initialize: (Herb::Config::LinterConfig config, rule_registry: RuleRegistry, ?ignore_disable_comments: bool) -> void

      # Lint a single file and return the result.
      #
      # Processing flow:
      # 1. Parse ERB template into AST
      # 2. Parse directives via DirectiveParser
      # 3. Check for file-level ignore
      # 4. Create Context and execute rules against the AST
      # 5. Build LintResult (filtering offenses and detecting unnecessary directives)
      #
      # @rbs file_path: String -- path to the file being linted
      # @rbs source: String -- source code content of the file
      def lint: (file_path: String, source: String) -> LintResult

      private

      # @rbs parse_result: Herb::ParseResult
      # @rbs context: Context
      def collect_offenses: (Herb::ParseResult parse_result, Context context) -> Array[Offense]

      # Determines if a rule should be applied to the given file path
      # based on per-rule include/only/exclude patterns.
      #
      # Pattern Resolution Logic:
      # 1. If rule has 'only': file must match one of 'only' patterns
      # 2. Else: file must match (linter.include OR rule.include)
      # 3. AND: file must NOT match (linter.exclude OR rule.exclude)
      #
      # @rbs rule_name: String
      # @rbs file_path: String
      def should_apply_rule?: (String rule_name, String file_path) -> bool

      # Check if file passes 'only' pattern restrictions
      # @rbs rule_name: String
      # @rbs file_path: String
      def passes_only_check?: (String rule_name, String file_path) -> bool

      # Check if file passes include pattern requirements
      # @rbs rule_name: String
      # @rbs file_path: String
      def passes_include_check?: (String rule_name, String file_path) -> bool

      # Check if file matches any exclude patterns
      # @rbs rule_name: String
      # @rbs file_path: String
      def matches_exclude_patterns?: (String rule_name, String file_path) -> bool

      # Check if file matches any pattern in the list
      # @rbs patterns: Array[String]
      # @rbs file_path: String
      def matches_pattern?: (Array[String] patterns, String file_path) -> bool

      # Build LintResult from offenses.
      # When ignore_disable_comments is false, filters offenses using directives
      # and detects unnecessary herb:disable directives.
      #
      # @rbs file_path: String
      # @rbs source: String
      # @rbs parse_result: Herb::ParseResult
      # @rbs directives: DirectiveParser::Directives
      # @rbs offenses: Array[Offense]
      def build_lint_result: (String file_path, String source, Herb::ParseResult parse_result, DirectiveParser::Directives directives, Array[Offense] offenses) -> LintResult

      # @rbs file_path: String
      # @rbs source: String
      # @rbs errors: Array[untyped]
      def parse_error_result: (String file_path, String source, Array[untyped] errors) -> LintResult

      # @rbs error: untyped
      def parse_error_offense: (untyped error) -> Offense
    end
  end
end
