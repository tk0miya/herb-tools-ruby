# Generated from lib/herb/format/format_helpers.rb with RBS::Inline

module Herb
  module Format
    # FormatHelpers module provides constants and helper functions for formatting.
    #
    # This module contains all the constants and helper functions used by the
    # FormatPrinter to make formatting decisions, analyze nodes, and determine
    # layout strategies.
    module FormatHelpers
      # HTML inline elements that should be kept on the same line when possible.
      # These elements typically don't start on a new line and flow with text.
      INLINE_ELEMENTS: Set[String]

      # Elements whose content should be preserved as-is without formatting.
      # These elements contain content where whitespace is significant.
      CONTENT_PRESERVING_ELEMENTS: Set[String]

      # Container elements that can have blank lines between children.
      # These are typically structural/semantic containers.
      SPACEABLE_CONTAINERS: Set[String]

      # Attributes whose values are space-separated token lists.
      # These require special handling to ensure spaces around dynamic content.
      TOKEN_LIST_ATTRIBUTES: Set[String]

      # Attributes that can be formatted (wrapped, normalized).
      # Key '*' applies to all elements, specific element names for element-specific attributes.
      FORMATTABLE_ATTRIBUTES: Hash[String, Array[String]]

      # Regular expression matching ASCII whitespace characters.
      # Used for normalizing whitespace in text content.
      ASCII_WHITESPACE: Regexp

      # ERB node types that represent control flow constructs (if/unless/case/for/while/etc.).
      ERB_CONTROL_FLOW_TYPES: Array[singleton(Herb::AST::Node)]

      # Check if a node is pure whitespace (HTMLTextNode with only whitespace).
      # Note: WhitespaceNode is NOT considered "pure whitespace".
      #
      # @rbs node: Herb::AST::Node
      def pure_whitespace_node?: (Herb::AST::Node node) -> bool

      # Check if a node is non-whitespace (has meaningful content).
      #
      # @rbs node: Herb::AST::Node
      def non_whitespace_node?: (Herb::AST::Node node) -> bool

      # Check if a tag name is an inline element.
      #
      # @rbs tag_name: String
      def inline_element?: (String tag_name) -> bool

      # Check if a tag name is content-preserving.
      #
      # @rbs tag_name: String
      def content_preserving?: (String tag_name) -> bool

      # Check if a node is block-level (not inline).
      #
      # @rbs node: Herb::AST::Node
      def block_level_node?: (Herb::AST::Node node) -> bool

      # Check if a node is a line-breaking element (br or hr).
      #
      # @rbs node: Herb::AST::Node
      def line_breaking_element?: (Herb::AST::Node node) -> bool

      # Check if a child is insignificant (should be filtered out).
      #
      # @rbs child: Herb::AST::Node
      def insignificant_child?: (Herb::AST::Node child) -> bool

      # Check if an HTML element is inline.
      #
      # @rbs child: Herb::AST::HTMLElementNode
      def inline_html_element?: (Herb::AST::HTMLElementNode child) -> bool

      # Check if a text node is non-empty.
      #
      # @rbs child: Herb::AST::HTMLTextNode
      def non_empty_text_node?: (Herb::AST::HTMLTextNode child) -> bool

      # Check if a node is an ERB node.
      #
      # @rbs node: Herb::AST::Node
      def erb_node?: (Herb::AST::Node node) -> bool

      # Check if a node is an ERB control flow node.
      #
      # @rbs node: Herb::AST::Node
      def erb_control_flow_node?: (Herb::AST::Node node) -> bool

      # Check if a node is a herb:disable comment (<%# herb:disable %>).
      # These comments disable formatting for adjacent content.
      #
      # @rbs node: Herb::AST::Node
      def herb_disable_comment?: (Herb::AST::Node node) -> bool

      # Remove common leading whitespace from multi-line text.
      # Blank lines are preserved as-is.
      #
      # @rbs text: String
      def dedent: (String text) -> String

      # Get the tag name from an HTMLElementNode.
      # Returns an empty string if not available.
      #
      # @rbs element_node: Herb::AST::HTMLElementNode
      def get_tag_name: (Herb::AST::HTMLElementNode element_node) -> String

      # Find the index of the previous meaningful (non-whitespace) sibling.
      # Returns nil if no meaningful sibling exists before current_index.
      #
      # @rbs siblings: Array[Herb::AST::Node]
      # @rbs current_index: Integer
      def find_previous_meaningful_sibling: (Array[Herb::AST::Node] siblings, Integer current_index) -> Integer?

      # Check if there is whitespace between two indices in children array.
      #
      # @rbs children: Array[Herb::AST::Node]
      # @rbs start_index: Integer
      # @rbs end_index: Integer
      def whitespace_between?: (Array[Herb::AST::Node] children, Integer start_index, Integer end_index) -> bool

      # Filter significant children from body, preserving single spaces.
      # Excludes empty text nodes and WhitespaceNode, but preserves single space " ".
      #
      # @rbs body: Array[Herb::AST::Node]
      def filter_significant_children: (Array[Herb::AST::Node] body) -> Array[Herb::AST::Node]

      # Count consecutive inline elements/ERB from start of children.
      # Stops when interrupted by whitespace, block element, or non-inline content.
      #
      # @rbs children: Array[Herb::AST::Node]
      def count_adjacent_inline_elements: (Array[Herb::AST::Node] children) -> Integer

      # Check if a node should be counted as an inline node.
      #
      # @rbs child: Herb::AST::Node
      def countable_inline_node?: (Herb::AST::Node child) -> bool

      # Check if any text nodes in children contain newlines.
      # Recursively checks nested element bodies.
      #
      # @rbs children: Array[Herb::AST::Node]
      def multiline_text_content?: (Array[Herb::AST::Node] children) -> bool

      # Check if all nested elements are inline.
      # Recursively checks nested element bodies.
      # Returns false for DOCTYPE, HTMLComment, and ERB control flow nodes.
      #
      # @rbs children: Array[Herb::AST::Node]
      def all_nested_elements_inline?: (Array[Herb::AST::Node] children) -> bool

      # Check if a single node qualifies as inline for nesting purposes.
      #
      # @rbs child: Herb::AST::Node
      def nested_inline_node?: (Herb::AST::Node child) -> bool

      # Check if children contain a mix of text and inline elements.
      # Returns true when both text content and inline elements (or ERB) are present.
      # Example: "Hello <em>world</em>!" has mixed text and inline content.
      # Returns false if any block-level element is present.
      #
      # @rbs children: Array[Herb::AST::Node]
      def mixed_text_and_inline_content?: (Array[Herb::AST::Node] children) -> bool

      # Check if a node qualifies as an inline element for mixed content detection.
      #
      # @rbs child: Herb::AST::Node
      def mixed_content_inline_node?: (Herb::AST::Node child) -> bool

      # Check if children contain complex ERB control flow that spans multiple lines.
      # An ERB control flow node is complex if its location spans more than one line.
      #
      # @rbs children: Array[Herb::AST::Node]
      def complex_erb_control_flow?: (Array[Herb::AST::Node] children) -> bool

      # Extract the attribute name as a string.
      #
      # @rbs attribute: Herb::AST::HTMLAttributeNode
      def get_attribute_name: (Herb::AST::HTMLAttributeNode attribute) -> String

      # Return normalized quote pair for an attribute value node.
      # Single quotes are converted to double quotes unless the content contains
      # a double quote character, in which case single quotes are preserved.
      # Unquoted attribute values are given double quotes.
      #
      # @rbs attribute_value: Herb::AST::HTMLAttributeValueNode
      def get_attribute_quotes: (Herb::AST::HTMLAttributeValueNode attribute_value) -> [ String, String ]

      # Extract plain text content from an attribute value node.
      # Returns text from HTMLTextNode and LiteralNode children only
      # (ERB nodes are excluded).
      #
      # @rbs attribute_value: Herb::AST::HTMLAttributeValueNode
      def get_html_text_content: (Herb::AST::HTMLAttributeValueNode attribute_value) -> String

      # Extract the string value from an optional token node.
      # Returns empty string when the token is absent.
      #
      # @rbs token: untyped
      def token_value: (untyped token) -> String

      # Check if a space is needed between the current line and the next word.
      # Returns false when:
      # - The word is closing punctuation (e.g., ")", ".", ",")
      # - The current line ends with opening punctuation (e.g., "(", "[")
      # - The word starts with an ERB tag and the current line ends with a non-word character
      #
      # @rbs current_line: String
      # @rbs word: String
      def needs_space_between?: (String current_line, String word) -> bool

      # Check if a word is closing punctuation (e.g., ")", ".", ",", "!").
      # No space should precede closing punctuation.
      #
      # @rbs word: String
      def closing_punctuation?: (String word) -> bool

      # Check if a string ends with opening punctuation (e.g., "(", "[", "{").
      # No space should follow opening punctuation.
      #
      # @rbs word: String
      def opening_punctuation?: (String word) -> bool

      # Check if a string ends with an ERB closing tag (%>).
      #
      # @rbs text: String
      def ends_with_erb_tag?: (String text) -> bool

      # Check if a string starts with an ERB opening tag (<%).
      #
      # @rbs text: String
      def starts_with_erb_tag?: (String text) -> bool

      # Check if a node can be appended to a previous inline element or ERB node.
      # Used internally by should_append_to_last_line?.
      #
      # @rbs child: Herb::AST::Node
      def appendable_after_inline_or_erb?: (Herb::AST::Node child) -> bool

      # Should the current node be appended to the previous line (no newline)?
      # Returns true when content should flow directly from the previous content:
      # - Text immediately after an inline element (no whitespace between)
      # - Adjacent inline elements (no whitespace between)
      # - ERB content on the same line as previous inline/text content
      #
      # @rbs child: Herb::AST::Node
      # @rbs siblings: Array[Herb::AST::Node]
      # @rbs index: Integer
      def should_append_to_last_line?: (Herb::AST::Node child, Array[Herb::AST::Node] siblings, Integer index) -> bool

      # Should user-intentional spacing (blank lines) be preserved?
      # Returns true when a whitespace node contains multiple newlines (\n\n)
      # and is surrounded by meaningful content nodes.
      #
      # @rbs child: Herb::AST::Node
      # @rbs siblings: Array[Herb::AST::Node]
      # @rbs index: Integer
      def should_preserve_user_spacing?: (Herb::AST::Node child, Array[Herb::AST::Node] siblings, Integer index) -> bool
    end
  end
end
