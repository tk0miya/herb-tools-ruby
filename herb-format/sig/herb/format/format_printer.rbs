# Generated from lib/herb/format/format_printer.rb with RBS::Inline

module Herb
  module Format
    # Core formatting printer that traverses AST and produces formatted output.
    #
    # Extends Printer::Base (which extends Herb::Visitor) to leverage the
    # standard visitor pattern with double-dispatch via node.accept(self).
    # This mirrors the TypeScript FormatPrinter extends Printer extends Visitor
    # architecture.
    #
    # Leaf nodes are handled with identity-like output for now. As formatting
    # rules are added, visitor methods will be overridden to apply indentation,
    # line wrapping, attribute formatting, and other transformations.
    class FormatPrinter < ::Herb::Printer::Base
      include FormatHelpers

      VOID_ELEMENTS: untyped

      PRESERVED_ELEMENTS: untyped

      attr_reader indent_width: Integer

      attr_reader max_line_length: Integer

      attr_reader format_context: Context

      attr_reader indent_level: Integer

      # Format the given input and return a formatted string.
      #
      # @rbs input: Herb::ParseResult | Herb::AST::Node
      # @rbs format_context: Context
      # @rbs ignore_errors: bool
      def self.format: (Herb::ParseResult | Herb::AST::Node input, format_context: Context, ?ignore_errors: bool) -> String

      @node_is_multiline: Hash[Herb::AST::Node, bool]

      @element_formatting_analysis: Hash[Herb::AST::HTMLElementNode, ElementAnalysis?]

      @element_stack: Array[Herb::AST::HTMLElementNode]

      @current_attribute_name: String?

      @in_conditional_open_tag_context: bool

      @inline_mode: bool

      @string_line_count: Integer

      @lines: Array[String]

      # @rbs indent_width: Integer
      # @rbs max_line_length: Integer
      # @rbs format_context: Context
      def initialize: (indent_width: Integer, max_line_length: Integer, format_context: Context) -> void

      # @rbs override
      def visit_literal_node: ...

      # @rbs override
      def visit_html_text_node: ...

      # @rbs override
      def visit_whitespace_node: ...

      # Visit HTML element node.
      # Pushes/pops @element_stack around child visiting so that open and close
      # tag visitors can access the enclosing element via current_element.
      # Pre-computes ElementAnalysis for non-preserved elements.
      #
      # @rbs override
      def visit_html_element_node: ...

      # Visit HTML open tag node.
      # Dispatches to inline or multiline rendering based on pre-computed
      # ElementAnalysis. Falls back to push_to_last_line for preserved elements
      # and during recursive analysis captures.
      #
      # @rbs override
      def visit_html_open_tag_node: ...

      # Visit HTML close tag node.
      # Appends inline when analysis says close_tag_inline or when in inline mode.
      # Otherwise pushes to a new indented line.
      # Falls back to push_to_last_line for preserved elements (no analysis).
      #
      # @rbs override
      def visit_html_close_tag_node: ...

      # Return the formatted output string.
      def formatted_output: () -> String

      # Capture output to a temporary buffer.
      # Saves and restores @lines, @string_line_count, and @inline_mode around the block.
      # Used by ElementAnalyzer to render elements speculatively for length checks.
      #
      # @rbs &block: () -> void
      def capture: () { () -> void } -> Array[String]

      # Visit ERB content node.
      # Routes comment nodes (<%# ... %>) to visit_erb_comment_node.
      # All other ERB content nodes are printed with normalized spacing.
      #
      # @rbs override
      def visit_erb_content_node: ...

      # Visit ERB end node (<% end %>).
      # Normalizes spacing and outputs using the push-based buffer.
      #
      # @rbs override
      def visit_erb_end_node: ...

      # Visit ERB if node.
      # Dispatches to inline mode (inside attributes) or block mode (normal).
      #
      # @rbs override
      def visit_erb_if_node: ...

      # Visit ERB block node (each, map, etc.).
      # Prints the opening ERB tag, then visits the body with increased indentation,
      # delegating to text-flow or element-children visitors based on context.
      # Finally visits the end node.
      #
      # @rbs override
      def visit_erb_block_node: ...

      # Visit ERB unless node.
      # Prints the unless tag, visits statements with increased indentation,
      # optionally visits else_clause, then visits end_node.
      #
      # @rbs override
      def visit_erb_unless_node: ...

      # Visit ERB else node.
      # Prints the else tag and visits statements.
      # In inline mode, visits statements without indentation; otherwise with indentation.
      #
      # @rbs override
      def visit_erb_else_node: ...

      # Visit ERB case node.
      # Prints the case tag, visits each when condition (conditions),
      # optionally visits else_clause, then visits end_node.
      #
      # @rbs override
      def visit_erb_case_node: ...

      # Visit ERB when node (inside case).
      # Prints the when tag and visits statements with increased indentation.
      #
      # @rbs override
      def visit_erb_when_node: ...

      # Visit ERB case/in node (pattern matching).
      # Prints the case tag, visits direct children (content between case and first in),
      # visits each in condition, optionally visits else_clause, then visits end_node.
      #
      # @rbs override
      def visit_erb_case_match_node: ...

      # Visit ERB in node (inside case/in pattern matching).
      # Prints the in tag and visits statements with increased indentation.
      #
      # @rbs override
      def visit_erb_in_node: ...

      # Visit ERB for node.
      # Prints the for tag, visits statements with increased indentation,
      # then visits end_node.
      #
      # @rbs override
      def visit_erb_for_node: ...

      # Visit ERB while node (same pattern as for).
      #
      # @rbs override
      def visit_erb_while_node: ...

      # Visit ERB until node (same pattern as for).
      #
      # @rbs override
      def visit_erb_until_node: ...

      private

      # Return the element currently being visited (top of element stack).
      # Raises if called outside of visit_html_element_node context.
      def current_element: () -> Herb::AST::HTMLElementNode

      # Return the tag name of the current element.
      def current_tag_name: () -> String

      # Current indent string based on indent_level.
      def indent: () -> String

      # Push line with indentation applied.
      # Empty or whitespace-only lines are pushed without indentation.
      #
      # @rbs line: String
      def push_with_indent: (String line) -> void

      # Append text to the last line in the buffer (no newline).
      # If buffer is empty, starts a new line.
      #
      # @rbs text: String
      def push_to_last_line: (String text) -> void

      # Push a line to the output buffer.
      #
      # @rbs line: String
      def push: (String line) -> void

      # Track if a node spans multiple lines.
      # Records whether the node produced multiline output.
      #
      # @rbs node: Herb::AST::Node
      # @rbs &block: () -> void
      def track_boundary: (Herb::AST::Node node) { () -> void } -> void

      # Temporarily increase indent level for the duration of the block.
      #
      # @rbs &block: () -> void
      def with_indent: () { () -> void } -> void

      # Temporarily enable inline mode for the duration of the block.
      #
      # @rbs &block: () -> void
      def with_inline_mode: () { () -> void } -> void

      # Visit the body of an HTML element.
      # For preserved elements (script, style, pre, textarea), content is output
      # as-is using IdentityPrinter. For elements with inline content analysis,
      # body is rendered in inline mode. For block elements, content is formatted
      # with increased indentation.
      #
      # @rbs node: Herb::AST::HTMLElementNode
      def visit_element_body: (Herb::AST::HTMLElementNode node) -> void

      # Generate indentation string for the current indent level.
      #
      # @rbs level: Integer
      def indent_string: (?Integer level) -> String

      # Check if tag is a void element (self-closing, no closing tag).
      #
      # @rbs tag_name: String
      def void_element?: (String tag_name) -> bool

      # Check if tag content should be preserved (not reformatted).
      #
      # @rbs tag_name: String
      def preserved_element?: (String tag_name) -> bool

      # Render attributes inline (same line).
      # Returns a string like ' class="foo" id="bar"', or "" if no attributes.
      #
      # @rbs open_tag: Herb::AST::HTMLOpenTagNode
      def render_attributes_inline: (Herb::AST::HTMLOpenTagNode open_tag) -> String

      # Render attributes in multiline format (one attribute per line).
      # Outputs:
      #   <tag_name [herb:disable comments]
      #     attr1="val1"
      #     attr2="val2"
      #   > (or /> for void elements)
      #
      # @rbs tag_name: String
      # @rbs children: Array[Herb::AST::Node]
      # @rbs is_void: bool
      def render_multiline_attributes: (String tag_name, Array[Herb::AST::Node] children, bool is_void) -> void

      # Render an ERB conditional/block node that appears inside an open tag's
      # attribute list (multiline format).
      # Prints the opening ERB tag, renders each HTMLAttributeNode statement
      # using render_attribute (preserving name="value" syntax), skips
      # whitespace, and finally prints the end node—all at the current indent.
      # Recurses into subsequent (else/elsif) branches for ERBIfNode, and
      # into else_clause for ERBUnlessNode.
      #
      # @rbs node: Herb::Core::AST::erb_control_flow_node | Herb::AST::ERBElseNode
      def render_conditional_attribute_block: (Herb::Core::AST::erb_control_flow_node | Herb::AST::ERBElseNode node) -> void

      # Render the statements of a conditional attribute block.
      # HTMLAttributeNodes are rendered with render_attribute; whitespace is skipped.
      #
      # @rbs node: Herb::Core::AST::erb_control_flow_node | Herb::AST::ERBElseNode
      #   | Herb::AST::ERBWhenNode | Herb::AST::ERBInNode
      def render_conditional_attribute_statements: (Herb::Core::AST::erb_control_flow_node | Herb::AST::ERBElseNode | Herb::AST::ERBWhenNode | Herb::AST::ERBInNode node) -> void

      # Render an ERBCaseNode that appears inside an open tag's attribute list.
      # Prints the case tag, each when/in condition with its attribute statements,
      # an optional else branch, and the end tag—all at the current indent.
      #
      # @rbs node: Herb::AST::ERBCaseNode | Herb::AST::ERBCaseMatchNode
      def render_case_attribute_block: (Herb::AST::ERBCaseNode | Herb::AST::ERBCaseMatchNode node) -> void

      # Render the content of an attribute value node.
      # Formats ERB control flow nodes inline using the push-based visitor.
      # Other non-literal nodes fall back to IdentityPrinter.
      #
      # @rbs attribute_value: Herb::AST::HTMLAttributeValueNode
      def render_attribute_value_content: (Herb::AST::HTMLAttributeValueNode attribute_value) -> String

      # Render a single attribute.
      # Returns a string like 'class="foo"' or 'disabled' (boolean attribute).
      #
      # @rbs attribute: Herb::AST::HTMLAttributeNode
      def render_attribute: (Herb::AST::HTMLAttributeNode attribute) -> String

      # Render the class attribute with optional multiline wrapping for long values.
      # Normalizes whitespace and wraps long class lists across multiple lines
      # when the attribute would exceed max_line_length.
      #
      # @rbs name: String
      # @rbs content: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      def render_class_attribute: (String name, String content, String open_quote, String close_quote) -> String

      # Wrap class attribute by splitting on original newlines.
      #
      # @rbs content: String
      # @rbs name: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      def wrap_class_by_newlines: (String content, String name, String open_quote, String close_quote) -> String?

      # Wrap class attribute by breaking long token sequences into lines.
      #
      # @rbs normalized_content: String
      # @rbs name: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      # @rbs current_indent: Integer
      def wrap_class_by_length: (String normalized_content, String name, String open_quote, String close_quote, Integer current_indent) -> String?

      # Break an array of tokens into lines that fit within max_line_length.
      #
      # @rbs tokens: Array[String]
      # @rbs indent: Integer
      def break_tokens_into_lines: (Array[String] tokens, Integer indent) -> Array[String]

      # Format an array of lines as a multiline attribute value.
      # Each line is indented with two spaces, and the result is wrapped
      # with leading and trailing newlines.
      #
      # @rbs lines: Array[String]
      def format_multiline_attribute_value: (Array[String] lines) -> String

      # Visit ERB comment node (<%# ... %>).
      # Handles comment formatting for both single and multi-line comments.
      # Single-line or collapsible multi-line: normalizes to <%# content %>.
      # True multi-line: formats as block with opening <%#, indented content lines,
      # and closing %> on its own line.
      #
      # @rbs node: Herb::AST::ERBContentNode
      def visit_erb_comment_node: (Herb::AST::ERBContentNode node) -> void

      # Visit ERB if node in inline mode (inside attributes).
      # Handles conditional rendering of attributes in open tags.
      # In token-list attributes (e.g., class, data-controller, data-action),
      # adds spaces before each child and before the closing <% end %> tag.
      #
      # @rbs node: Herb::AST::ERBIfNode
      def visit_erb_if_inline: (Herb::AST::ERBIfNode node) -> void

      # Visit a single statement child of an ERBIfNode in inline mode.
      # HTMLAttributeNodes are rendered as attribute strings.
      # Text content is pushed directly. Other nodes are visited normally.
      # In token-list attribute context, a space is added before each child.
      #
      # @rbs child: Herb::AST::Node
      def visit_erb_if_inline_statement: (Herb::AST::Node child) -> void

      # Visit ERB if node in block mode (normal, outside attributes).
      # Implemented in Task 2.25.
      #
      # @rbs node: Herb::AST::ERBIfNode
      def visit_erb_if_block: (Herb::AST::ERBIfNode node) -> void

      # Should a blank line be added before siblings[current_index]?
      # Implements a simplified "Rule of Three" spacing heuristic:
      # 1. Always adds spacing after XML declaration or DOCTYPE.
      # 2. Suppresses spacing when siblings contain mixed text content.
      # 3. Comment handling: comment followed by non-comment element adds spacing
      #    only when BOTH are multiline (treats comment as attached documentation);
      #    two consecutive comments never get spacing between them.
      # 4. Adds spacing when either the current or previous node is multiline.
      # (Tag-group detection is deferred to a later task.)
      #
      # @rbs _parent_element: Herb::AST::HTMLElementNode?
      # @rbs siblings: Array[Herb::AST::Node]
      # @rbs current_index: Integer
      def should_add_spacing_between_siblings?: (untyped _parent_element, Array[Herb::AST::Node] siblings, Integer current_index) -> bool

      # Check if children form a text flow context.
      # Returns true when: non-empty text content exists, non-text children
      # exist, and all non-text children are inline elements or ERB content nodes.
      #
      # @rbs _parent: Herb::AST::Node?
      # @rbs children: Array[Herb::AST::Node]
      def in_text_flow_context?: (untyped _parent, Array[Herb::AST::Node] children) -> bool

      # Build content units from children nodes for text flow processing.
      # Each node is classified into a ContentUnit with type, atomicity, and
      # flow-breaking properties. Used by build_and_wrap_text_flow (Task 2.31).
      #
      # @rbs children: Array[Herb::AST::Node]
      def build_content_units_with_nodes: (Array[Herb::AST::Node] children) -> Array[content_unit_with_node]

      # Visit children in text flow mode.
      # Builds content units and wraps text across lines respecting max_line_length.
      #
      # @rbs children: Array[Herb::AST::Node]
      def visit_text_flow_children: (Array[Herb::AST::Node] children) -> void

      # Visit children as block elements, skipping pure whitespace nodes.
      # Note: Full implementation provided in Task 2.34 (Part F).
      #
      # @rbs children: Array[Herb::AST::Node]
      # @rbs _parent: Herb::AST::HTMLElementNode?
      def visit_element_children: (Array[Herb::AST::Node] children, untyped _parent) -> void

      # Build a content unit for a text node.
      #
      # @rbs child: Herb::AST::HTMLTextNode
      def process_text_node: (Herb::AST::HTMLTextNode child) -> content_unit_with_node

      # Build a content unit for an HTML element node.
      # Inline elements are rendered atomically via capture in inline mode so that
      # indentation is not prepended to the captured string.
      # Block elements break the text flow.
      #
      # @rbs child: Herb::AST::HTMLElementNode
      def process_element_node: (Herb::AST::HTMLElementNode child) -> content_unit_with_node

      # Build a content unit for an ERB content node.
      # Determines is_herb_disable by inspecting the node's comment marker.
      # The _children, _index, and _last_processed_index parameters are reserved
      # for future lookahead processing (e.g. collapsing adjacent ERB nodes).
      #
      # @rbs _children: Array[Herb::AST::Node]
      # @rbs child: Herb::AST::ERBContentNode
      # @rbs _index: Integer
      # @rbs _last_processed_index: Integer
      def process_erb_content_node: (untyped _children, Herb::AST::ERBContentNode child, untyped _index, untyped _last_processed_index) -> content_unit_with_node

      # Render an ERB content node as a formatted string.
      #
      # @rbs node: Herb::AST::ERBContentNode
      def render_erb_as_string: (Herb::AST::ERBContentNode node) -> String

      # Build content units from children and wrap text across lines.
      # Flow-breaking (block) nodes are flushed and visited separately.
      # Atomic units (ERB, inline elements) are added to the word buffer as-is.
      # Text nodes are split into words with space tracking via process_text_unit.
      #
      # @rbs children: Array[Herb::AST::Node]
      def build_and_wrap_text_flow: (Array[Herb::AST::Node] children) -> void

      # Process a text content string into the word accumulator.
      # Normalizes whitespace runs to single spaces and splits on word boundaries.
      # Spacing between units is handled entirely by flush_words via needs_space_between?.
      #
      # @rbs words: Array[{ word: String, is_herb_disable: bool }]
      # @rbs text: String
      def process_text_unit: (Array[{ word: String, is_herb_disable: bool }] words, String text) -> void

      # Flush accumulated words to the output buffer with line-wrapping.
      # Words are joined with spaces (via needs_space_between?) and wrapped
      # when the line would exceed wrap_width. herb:disable units are never
      # used as a wrap point. Clears the words array after flushing.
      #
      # @rbs words: Array[{ word: String, is_herb_disable: bool }]
      def flush_words: (Array[{ word: String, is_herb_disable: bool }] words) -> void

      # Append a word to the current line or wrap to a new line.
      # Returns the updated current line. When wrapping occurs, the previous
      # line is pushed to the output buffer and the word starts a new line.
      #
      # @rbs current_line: String
      # @rbs word_hash: { word: String, is_herb_disable: bool }
      # @rbs wrap_width: Integer
      def append_word_to_line: (String current_line, { word: String, is_herb_disable: bool } word_hash, Integer wrap_width) -> String

      # Check whether the printer is currently rendering inside a token-list attribute.
      # Token-list attributes (e.g., class, data-controller, data-action) separate
      # values with spaces, so ERB conditionals within them need space padding.
      def in_token_list_attribute?: () -> bool

      # Check if a node produced multiline output during formatting.
      # Uses the @node_is_multiline tracking hash populated by track_boundary.
      #
      # @rbs node: Herb::AST::Node
      def multiline_element?: (Herb::AST::Node node) -> bool

      # Format ERB content by normalizing whitespace.
      # Adds a leading space and a trailing space (or newline for heredocs).
      # Returns empty string when content is blank.
      #
      # @rbs content: String
      def format_erb_content: (String content) -> String

      # Reconstruct an ERB node as a string.
      # When with_formatting is true, the content is normalized via format_erb_content.
      #
      # @rbs node: Herb::AST::ERBContentNode
      # @rbs with_formatting: bool
      def reconstruct_erb_node: (Herb::AST::ERBContentNode node, ?with_formatting: bool) -> String

      # Print an ERB node to the output buffer.
      # In inline mode, appends to the last line without a newline separator.
      # Otherwise, pushes a new line with the current indent prepended.
      #
      # @rbs node: Herb::AST::ERBContentNode
      def print_erb_node: (Herb::AST::ERBContentNode node) -> void
    end
  end
end
