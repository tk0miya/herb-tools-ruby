# Generated from lib/herb/format/format_printer.rb with RBS::Inline

module Herb
  module Format
    # Core formatting printer that traverses AST and produces formatted output.
    #
    # Extends Printer::Base (which extends Herb::Visitor) to leverage the
    # standard visitor pattern with double-dispatch via node.accept(self).
    # This mirrors the TypeScript FormatPrinter extends Printer extends Visitor
    # architecture.
    #
    # Leaf nodes are handled with identity-like output for now. As formatting
    # rules are added, visitor methods will be overridden to apply indentation,
    # line wrapping, attribute formatting, and other transformations.
    class FormatPrinter < ::Herb::Printer::Base
      include FormatHelpers

      VOID_ELEMENTS: untyped

      PRESERVED_ELEMENTS: untyped

      attr_reader indent_width: Integer

      attr_reader max_line_length: Integer

      attr_reader format_context: Context

      attr_reader indent_level: Integer

      # Format the given input and return a formatted string.
      #
      # @rbs input: Herb::ParseResult | Herb::AST::Node
      # @rbs format_context: Context
      # @rbs ignore_errors: bool
      def self.format: (Herb::ParseResult | Herb::AST::Node input, format_context: Context, ?ignore_errors: bool) -> String

      @node_is_multiline: Hash[Herb::AST::Node, bool]

      @element_formatting_analysis: Hash[Herb::AST::HTMLElementNode, ElementAnalysis]

      @current_attribute_name: String?

      @in_conditional_open_tag_context: bool

      @inline_mode: bool

      @string_line_count: Integer

      @indent_level: Integer

      @lines: Array[String]

      # @rbs indent_width: Integer
      # @rbs max_line_length: Integer
      # @rbs format_context: Context
      def initialize: (indent_width: Integer, max_line_length: Integer, format_context: Context) -> void

      # @rbs override
      def visit_literal_node: ...

      # @rbs override
      def visit_html_text_node: ...

      # @rbs override
      def visit_whitespace_node: ...

      # Visit HTML element node. Handles void elements (no close tag) and
      # preserved elements (content unchanged) specially.
      #
      # @rbs override
      def visit_html_element_node: ...

      # Visit HTML open tag node.
      # Outputs the opening tag structure: <tag_name attributes>
      #
      # @rbs override
      def visit_html_open_tag_node: ...

      # Visit HTML close tag node.
      # Outputs the closing tag structure: </tag_name>
      #
      # @rbs override
      def visit_html_close_tag_node: ...

      # Capture output to a temporary buffer.
      # Saves and restores @lines, @string_line_count, and @inline_mode around the block.
      # Used by ElementAnalyzer to render elements speculatively for length checks.
      #
      # @rbs &block: () -> void
      def capture: () { () -> void } -> Array[String]

      private

      # Current indent string based on indent_level.
      def indent: () -> String

      # Push line with indentation applied.
      # Empty or whitespace-only lines are pushed without indentation.
      #
      # @rbs line: String
      def push_with_indent: (String line) -> void

      # Append text to the last line in the buffer (no newline).
      # If buffer is empty, starts a new line.
      #
      # @rbs text: String
      def push_to_last_line: (String text) -> void

      # Push a line to the output buffer.
      #
      # @rbs line: String
      def push: (String line) -> void

      # Track if a node spans multiple lines.
      # Records whether the node produced multiline output.
      #
      # @rbs node: Herb::AST::Node
      # @rbs &block: () -> void
      def track_boundary: (Herb::AST::Node node) { () -> void } -> void

      # Temporarily increase indent level for the duration of the block.
      #
      # @rbs &block: () -> void
      def with_indent: () { () -> void } -> void

      # Temporarily enable inline mode for the duration of the block.
      #
      # @rbs &block: () -> void
      def with_inline_mode: () { () -> void } -> void

      # Visit the body of an HTML element. For preserved elements (script,
      # style, pre, textarea), content is output as-is using IdentityPrinter.
      # For normal elements, content is formatted with increased indentation.
      #
      # @rbs node: Herb::AST::HTMLElementNode
      def visit_element_body: (Herb::AST::HTMLElementNode node) -> void

      # Generate indentation string for the current indent level.
      #
      # @rbs level: Integer
      def indent_string: (?Integer level) -> String

      # Check if tag is a void element (self-closing, no closing tag).
      #
      # @rbs tag_name: String
      def void_element?: (String tag_name) -> bool

      # Check if tag content should be preserved (not reformatted).
      #
      # @rbs tag_name: String
      def preserved_element?: (String tag_name) -> bool

      # Render attributes inline (same line).
      # Returns a string like ' class="foo" id="bar"', or "" if no attributes.
      #
      # @rbs open_tag: Herb::AST::HTMLOpenTagNode
      def render_attributes_inline: (Herb::AST::HTMLOpenTagNode open_tag) -> String

      # Render attributes in multiline format (one attribute per line).
      # Outputs:
      #   <tag_name [herb:disable comments]
      #     attr1="val1"
      #     attr2="val2"
      #   > (or /> for void elements)
      #
      # @rbs tag_name: String
      # @rbs children: Array[Herb::AST::Node]
      # @rbs is_void: bool
      def render_multiline_attributes: (String tag_name, Array[Herb::AST::Node] children, bool is_void) -> void

      # Render a single attribute.
      # Returns a string like 'class="foo"' or 'disabled' (boolean attribute).
      #
      # @rbs attribute: Herb::AST::HTMLAttributeNode
      def render_attribute: (Herb::AST::HTMLAttributeNode attribute) -> String

      # Extract the attribute name as a string.
      #
      # @rbs attribute: Herb::AST::HTMLAttributeNode
      def get_attribute_name: (Herb::AST::HTMLAttributeNode attribute) -> String

      # Return normalized quote pair (always double quotes).
      #
      # @rbs _attribute_value: Herb::AST::HTMLAttributeValueNode
      def get_attribute_quotes: (untyped _attribute_value) -> [ String, String ]

      # Render the content of an attribute value node.
      # Handles literal content and embedded ERB nodes.
      #
      # @rbs attribute_value: Herb::AST::HTMLAttributeValueNode
      def render_attribute_value_content: (Herb::AST::HTMLAttributeValueNode attribute_value) -> String

      # Render the class attribute with optional multiline wrapping for long values.
      # Normalizes whitespace and wraps long class lists across multiple lines
      # when the attribute would exceed max_line_length.
      #
      # @rbs name: String
      # @rbs content: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      def render_class_attribute: (String name, String content, String open_quote, String close_quote) -> String

      # Wrap class attribute by splitting on original newlines.
      #
      # @rbs content: String
      # @rbs name: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      def wrap_class_by_newlines: (String content, String name, String open_quote, String close_quote) -> String?

      # Wrap class attribute by breaking long token sequences into lines.
      #
      # @rbs normalized_content: String
      # @rbs name: String
      # @rbs open_quote: String
      # @rbs close_quote: String
      # @rbs current_indent: Integer
      def wrap_class_by_length: (String normalized_content, String name, String open_quote, String close_quote, Integer current_indent) -> String?

      # Break an array of tokens into lines that fit within max_line_length.
      #
      # @rbs tokens: Array[String]
      # @rbs indent: Integer
      def break_tokens_into_lines: (Array[String] tokens, Integer indent) -> Array[String]

      # Format an array of lines as a multiline attribute value.
      # Each line is indented with two spaces, and the result is wrapped
      # with leading and trailing newlines.
      #
      # @rbs lines: Array[String]
      def format_multiline_attribute_value: (Array[String] lines) -> String

      # Format ERB content by normalizing whitespace.
      # Adds a leading space and a trailing space (or newline for heredocs).
      # Returns empty string when content is blank.
      #
      # @rbs content: String
      def format_erb_content: (String content) -> String

      # Extract the string value from an optional token node.
      # Returns empty string when the token is absent.
      #
      # @rbs token: untyped
      def erb_token_value: (untyped token) -> String

      # Reconstruct an ERB node as a string.
      # When with_formatting is true, the content is normalized via format_erb_content.
      #
      # @rbs node: Herb::AST::ERBContentNode
      # @rbs with_formatting: bool
      def reconstruct_erb_node: (Herb::AST::ERBContentNode node, ?with_formatting: bool) -> String

      # Print an ERB node to the output buffer.
      # In inline mode no indentation is added; otherwise the current indent is prepended.
      #
      # @rbs node: Herb::AST::ERBContentNode
      def print_erb_node: (Herb::AST::ERBContentNode node) -> void
    end
  end
end
