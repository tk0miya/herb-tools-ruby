# Printer (AST Unparse) Detailed Design

Detailed design document for the herb-printer gem: AST-to-source-code printer infrastructure.

## Overview

The Printer provides AST-to-source-code conversion for Herb's ERB/HTML AST. It is the inverse of parsing: given an AST produced by `Herb.parse`, the printer reconstructs the source code string.

The primary implementation, `IdentityPrinter`, performs **lossless round-trip** reconstruction -- `IdentityPrinter.print(Herb.parse(source))` produces output identical to the original source.

This infrastructure serves as a foundation for:
- **herb-format**: Serialize a modified AST back to source code after formatting transformations
- **herb-lint**: Future auto-fix capabilities that modify AST nodes and re-serialize

## Reference Implementation

The TypeScript reference is `@herb-tools/printer` in the [herb repository](https://github.com/marcoroth/herb):

| TypeScript | Ruby |
|-----------|------|
| `Printer` (abstract class extending `Visitor`) | `Herb::Printer::Base` |
| `IdentityPrinter` (lossless round-trip) | `Herb::Printer::IdentityPrinter` |
| `PrintContext` (output buffer) | `Herb::Printer::PrintContext` |
| `IdentityPrinter.print(parseResult)` | `Herb::Printer::IdentityPrinter.print(parse_result)` |

## Why a Separate Gem

The TypeScript reference has a dedicated `@herb-tools/printer` package. A standalone herb-printer gem:

- Matches the TypeScript package structure (`@herb-tools/printer`)
- Separates concerns: file discovery (herb-core) vs AST serialization (herb-printer) are distinct responsibilities
- Allows herb-format and herb-lint to depend on it independently

## Directory Structure

```
herb-printer/
├── bin/                         # Binstubs (uses herb-printer/Gemfile)
│   ├── rake
│   ├── rbs
│   ├── rbs-inline
│   ├── rspec
│   ├── rubocop
│   └── steep
├── lib/
│   └── herb/
│       ├── printer.rb           # Entry point (requires + module definition)
│       └── printer/
│           ├── base.rb          # Abstract base class
│           ├── identity_printer.rb  # Lossless round-trip printer
│           ├── print_context.rb     # Output buffer with tracking
│           └── version.rb       # Version constant
├── spec/
│   └── herb/
│       └── printer/
│           ├── base_spec.rb
│           ├── identity_printer_spec.rb
│           └── print_context_spec.rb
├── sig/generated/herb/printer/  # Auto-generated by rbs-inline
├── .gitignore
├── .rspec
├── .rubocop.yml
├── Gemfile
├── Gemfile.lock
├── Rakefile
├── Steepfile
├── herb-printer.gemspec
├── rbs_collection.lock.yaml
└── rbs_collection.yaml
```

## Class Design

### Module Structure

```
Herb::Printer
├── PrintContext        # Output buffer with indent/column tracking
├── Base                # Abstract base class (extends Herb::Visitor)
│   └── PrintError      # Error raised when printing AST with errors
└── IdentityPrinter     # Lossless round-trip printer
```

### Inheritance

```
Herb::Visitor
└── Herb::Printer::Base              # Adds print() API, write() helper, error checking
    └── Herb::Printer::IdentityPrinter  # Overrides all visit_*_node methods
```

## Component Details

### Herb::Printer::PrintContext

Output accumulator with infrastructure for indent/column tracking. The `IdentityPrinter` uses only `write`, `get_output`, and `reset`. The remaining methods provide infrastructure for future formatting printers.

```rbs
class Herb::Printer::PrintContext
  @output: String
  @indent_level: Integer
  @current_column: Integer
  @tag_stack: Array[String]

  def initialize: () -> void

  # Append text to the output buffer
  def write: (String text) -> void

  # Append text and track column position across newlines
  def write_with_column_tracking: (String text) -> void

  # Increment indent level
  def indent: () -> void

  # Decrement indent level
  def dedent: () -> void

  # Push tag name onto the preserve stack (for tracking nesting)
  def enter_tag: (String tag_name) -> void

  # Pop tag name from the preserve stack
  def exit_tag: () -> void

  # Whether the cursor is at column 0
  def at_start_of_line?: () -> bool

  # Current indent depth
  def current_indent_level: () -> Integer

  # Current column position (0-based)
  def current_column: () -> Integer

  # Copy of the current tag stack
  def tag_stack: () -> Array[String]

  # Return accumulated output string
  def get_output: () -> String

  # Clear all state (output, indent, column, tag stack)
  def reset: () -> void
end
```

**Responsibilities:**
- Accumulate output text via `write`
- Track indent level for future formatting printers
- Track column position for line-length-aware formatting
- Maintain tag nesting stack for context-aware printing (e.g. `<pre>` content preservation)

### Herb::Printer::Base

Abstract base class that extends `Herb::Visitor` and adds the `print` API. Subclasses override `visit_*_node` methods to define how each node type is serialized.

A `Base` subclass with no overridden visit methods produces empty output (the default `visit_*_node` methods only traverse children without writing).

```rbs
class Herb::Printer::Base < Herb::Visitor
  @context: Herb::Printer::PrintContext

  def initialize: () -> void

  # Class-level convenience method
  def self.print: (
    Herb::ParseResult | Herb::AST::Node | Herb::Token | Array[Herb::AST::Node] | nil input,
    ?ignore_errors: bool
  ) -> String

  # Instance-level print method (allows reuse of printer instance)
  def print: (
    Herb::ParseResult | Herb::AST::Node | Herb::Token | Array[Herb::AST::Node] | nil input,
    ?ignore_errors: bool
  ) -> String

  private

  # Write text to the output context
  def write: (String text) -> void

  # Print from a ParseResult (extracts root node)
  def print_parse_result: (Herb::ParseResult result, ignore_errors: bool) -> String

  # Print a single AST node
  def print_node: (Herb::AST::Node node, ignore_errors: bool) -> String

  # Print an array of AST nodes
  def print_nodes: (Array[Herb::AST::Node] nodes, ignore_errors: bool) -> String

  # Raise PrintError if node tree contains parse errors
  def validate_no_errors!: (Herb::AST::Node node) -> void
end

class Herb::Printer::PrintError < StandardError
end
```

**Responsibilities:**
- Accept multiple input types (`ParseResult`, `Node`, `Token`, `Array`, `nil`)
- Validate AST has no parse errors before printing (unless `ignore_errors: true`)
- Provide `write` helper for subclasses
- Manage `PrintContext` lifecycle (reset before each print call)

**Input handling:**

| Input Type | Behavior |
|-----------|----------|
| `nil` | Returns `""` |
| `Token` | Returns `token.value` directly (no visitor traversal) |
| `ParseResult` | Extracts root node via `.value`, validates errors, visits |
| `Node` | Validates errors, resets context, visits, returns output |
| `Array[Node]` | Resets context, visits each node in order, returns output |

**Error handling:**

When `ignore_errors` is `false` (default) and the AST contains parse errors (checked via `node.recursive_errors`), `print` raises `PrintError` with a descriptive message. This prevents silently producing incorrect output from a malformed AST.

### Herb::Printer::IdentityPrinter

Lossless round-trip printer. Overrides all 28 `visit_*_node` methods to reconstruct the original source code exactly.

```rbs
class Herb::Printer::IdentityPrinter < Herb::Printer::Base
  # --- Document ---
  def visit_document_node: (Herb::AST::DocumentNode node) -> void

  # --- HTML Leaf Nodes ---
  def visit_literal_node: (Herb::AST::LiteralNode node) -> void
  def visit_html_text_node: (Herb::AST::HTMLTextNode node) -> void
  def visit_whitespace_node: (Herb::AST::WhitespaceNode node) -> void

  # --- HTML Structure ---
  def visit_html_element_node: (Herb::AST::HTMLElementNode node) -> void
  def visit_html_open_tag_node: (Herb::AST::HTMLOpenTagNode node) -> void
  def visit_html_close_tag_node: (Herb::AST::HTMLCloseTagNode node) -> void

  # --- HTML Attributes ---
  def visit_html_attribute_node: (Herb::AST::HTMLAttributeNode node) -> void
  def visit_html_attribute_name_node: (Herb::AST::HTMLAttributeNameNode node) -> void
  def visit_html_attribute_value_node: (Herb::AST::HTMLAttributeValueNode node) -> void

  # --- HTML Comment / Doctype / XML / CDATA ---
  def visit_html_comment_node: (Herb::AST::HTMLCommentNode node) -> void
  def visit_html_doctype_node: (Herb::AST::HTMLDoctypeNode node) -> void
  def visit_xml_declaration_node: (Herb::AST::XMLDeclarationNode node) -> void
  def visit_cdata_node: (Herb::AST::CDATANode node) -> void

  # --- ERB Nodes ---
  def visit_erb_content_node: (Herb::AST::ERBContentNode node) -> void
  def visit_erb_end_node: (Herb::AST::ERBEndNode node) -> void
  def visit_erb_yield_node: (Herb::AST::ERBYieldNode node) -> void
  def visit_erb_block_node: (Herb::AST::ERBBlockNode node) -> void
  def visit_erb_if_node: (Herb::AST::ERBIfNode node) -> void
  def visit_erb_else_node: (Herb::AST::ERBElseNode node) -> void
  def visit_erb_unless_node: (Herb::AST::ERBUnlessNode node) -> void
  def visit_erb_case_node: (Herb::AST::ERBCaseNode node) -> void
  def visit_erb_case_match_node: (Herb::AST::ERBCaseMatchNode node) -> void
  def visit_erb_when_node: (Herb::AST::ERBWhenNode node) -> void
  def visit_erb_in_node: (Herb::AST::ERBInNode node) -> void
  def visit_erb_while_node: (Herb::AST::ERBWhileNode node) -> void
  def visit_erb_until_node: (Herb::AST::ERBUntilNode node) -> void
  def visit_erb_for_node: (Herb::AST::ERBForNode node) -> void
  def visit_erb_begin_node: (Herb::AST::ERBBeginNode node) -> void
  def visit_erb_rescue_node: (Herb::AST::ERBRescueNode node) -> void
  def visit_erb_ensure_node: (Herb::AST::ERBEnsureNode node) -> void

  private

  # Shared helper: write tag_opening + content + tag_closing tokens for ERB nodes
  def print_erb_tag: (Herb::AST::Node node) -> void

  # Split child nodes around a token's position (used for HTMLCloseTagNode)
  def split_children_around_token: (
    Array[Herb::AST::Node] children,
    Herb::Token token
  ) -> [Array[Herb::AST::Node], Array[Herb::AST::Node]]
end
```

**Responsibilities:**
- Reconstruct source code losslessly from AST
- Handle Token properties (not part of `child_nodes`) explicitly
- Handle whitespace nodes for faithful round-trip

**Node handling patterns:**

Each node type falls into one of these serialization patterns:

| Pattern | Nodes | Strategy |
|---------|-------|----------|
| Leaf text | `LiteralNode`, `HTMLTextNode` | Write `node.content` (String) |
| Leaf token | `WhitespaceNode` | Write `node.value.value` (Token) |
| Tag wrapper | `HTMLOpenTagNode`, `HTMLDoctypeNode`, `XMLDeclarationNode`, `CDATANode` | Write `tag_opening` + visit children + write `tag_closing` |
| Close tag | `HTMLCloseTagNode` | Write `tag_opening` + split children around `tag_name` + write `tag_closing` |
| Comment | `HTMLCommentNode` | Write `comment_start` + visit children + write `comment_end` |
| Element | `HTMLElementNode` | Track tag in context + visit `open_tag` + visit `body` + visit `close_tag` |
| Attribute | `HTMLAttributeNode` | Visit `name` + write `equals` + visit `value` |
| Attribute value | `HTMLAttributeValueNode` | Write `open_quote` + visit children + write `close_quote` |
| ERB leaf | `ERBContentNode`, `ERBEndNode`, `ERBYieldNode` | Write `tag_opening` + `content` + `tag_closing` via `print_erb_tag` |
| ERB control | `ERBIfNode`, `ERBBlockNode`, etc. | `print_erb_tag` + visit body/statements + visit clauses + visit `end_node` |

**Key implementation note -- HTMLCloseTagNode:**

The close tag requires special handling because its `tag_name` is a Token (not a child node), but `WhitespaceNode` children can appear before or after the tag name (e.g. `</ div >`). The `split_children_around_token` method uses location-based comparison to partition children into before/after groups relative to the tag name token's position. This mirrors the TypeScript implementation's use of `getNodesBeforePosition`/`getNodesAfterPosition`.

**Key implementation note -- ERB nodes:**

All ERB nodes share three Token properties (`tag_opening`, `content`, `tag_closing`) that are NOT included in `child_nodes`. The `print_erb_tag` helper writes these explicitly. ERB control flow nodes additionally have structural properties (`statements`, `subsequent`, `else_clause`, `end_node`, etc.) that contain child nodes -- these are visited after the ERB tag tokens.

## Public API

### Basic Usage

```ruby
require "herb/printer"

# Round-trip: parse and reconstruct
source = '<div class="container"><%= user.name %></div>'
result = Herb.parse(source)
output = Herb::Printer::IdentityPrinter.print(result)
# output == source

# Print a single node
output = Herb::Printer::IdentityPrinter.print(some_node)

# Print a token directly
output = Herb::Printer::IdentityPrinter.print(some_token)
# => token.value

# Print node array
output = Herb::Printer::IdentityPrinter.print(node_array)
```

### Error Handling

```ruby
# Default: raises on parse errors
result = Herb.parse("<div><span></div>")  # malformed
Herb::Printer::IdentityPrinter.print(result)
# => raises Herb::Printer::PrintError

# Opt-in: ignore errors
output = Herb::Printer::IdentityPrinter.print(result, ignore_errors: true)
```

### Instance Reuse

```ruby
printer = Herb::Printer::IdentityPrinter.new
output1 = printer.print(result1)
output2 = printer.print(result2)
```

### Custom Printer (Extension Point)

```ruby
# Future: formatting printer for herb-format
class FormattingPrinter < Herb::Printer::Base
  def visit_html_element_node(node)
    @context.enter_tag(node.tag_name&.value || "")
    @context.indent
    visit(node.open_tag)
    # ... custom formatting logic ...
    @context.dedent
    @context.exit_tag
  end
end
```

## Design Decisions

### Separate gem (herb-printer)

The TypeScript reference has a dedicated `@herb-tools/printer` package. A standalone gem maintains the same structure and separates the distinct concerns of file discovery (herb-core) and AST serialization (herb-printer).

### Base class naming

The abstract base class is `Herb::Printer::Base` rather than `Herb::Printer::Printer` to avoid redundancy. This follows the convention used in `Herb::Lint::Rules::Base` and `Herb::Format::Rewriters::Base`.

### Visitor-Based Architecture

The printer extends `Herb::Visitor` rather than using a standalone recursive traversal. This matches the TypeScript reference and reuses the established double-dispatch pattern (`node.accept(visitor)` calls `visitor.visit_*_node(node)`).

### Explicit Token Writing vs visit_child_nodes

Many AST node properties are `Token` objects (e.g. `tag_opening`, `tag_name`, `tag_closing`), not child nodes. Since `child_nodes` only returns Node children, the printer must explicitly write Token values. This is why ERB node visit methods call `print_erb_tag` (for Token properties) and then `visit_all(node.statements)` (for Node children) separately -- relying on `visit_child_nodes` alone would skip all Token content.

### Error Checking by Default

Printing an AST with parse errors can produce incorrect or incomplete output. The default `ignore_errors: false` prevents silent data corruption. Users who need best-effort output (e.g. editor integrations) can opt in with `ignore_errors: true`.

### PrintContext Separation

`PrintContext` is a separate class rather than inline state in `Base` because:
1. Future formatting printers need richer context (indent tracking, column tracking, tag stack)
2. Context can be reset independently between print calls
3. Custom printers may want to inspect context state during traversal

## Dependencies

```ruby
# herb-printer.gemspec
spec.add_dependency "herb", "~> 0.1"
```

The gem depends on `herb` for `Herb::Visitor`, `Herb::AST::*` nodes, `Herb::Token`, and `Herb::ParseResult`. It has no dependency on herb-core or herb-config.

## Testing Strategy

### Test Categories

**1. PrintContext Unit Tests**

Verify buffer accumulation and state management:
- `write` appends text
- `get_output` returns accumulated text
- `reset` clears all state
- `indent`/`dedent` track indent level
- `write_with_column_tracking` tracks column across newlines
- `enter_tag`/`exit_tag` maintain tag stack
- `at_start_of_line?` reflects column position

**2. Base Class Tests**

Verify input dispatch and error handling:
- `nil` input returns `""`
- `Token` input returns `token.value`
- `ParseResult` input extracts and visits root node
- `Node` input visits the node
- `Array` input visits each node
- `PrintError` raised when AST has errors and `ignore_errors: false`
- No error raised when `ignore_errors: true`
- Bare `Base` subclass (no overrides) produces empty output

**3. IdentityPrinter Round-Trip Tests**

The most important test category. Parse source, print, and verify output equals input:

```ruby
[
  # HTML basics
  '<div></div>',
  '<div class="container">Hello</div>',
  '<img src="photo.jpg" alt="Photo">',
  '<br>',

  # HTML comments and doctype
  '<!-- comment -->',
  '<!DOCTYPE html>',

  # Attributes
  '<input type="text" disabled>',
  "<div class='single-quoted'>text</div>",

  # ERB expressions
  '<%= user.name %>',
  '<%# comment %>',
  '<%= yield %>',

  # ERB control flow
  '<% if condition %>yes<% else %>no<% end %>',
  '<% unless done %>work<% end %>',
  '<% items.each do |item| %><li><%= item %></li><% end %>',
  '<% case x %><% when 1 %>one<% when 2 %>two<% end %>',
  '<% while running %><%= status %><% end %>',
  '<% begin %><%= risky %><% rescue %><%= fallback %><% end %>',

  # Mixed
  '<div><%= yield %></div>',
  '<a href="<%= url %>"><%= text %></a>',

  # Multiline
  "<div>\n  <p>Hello</p>\n</div>",
].each do |source|
  it "round-trips: #{source.inspect.truncate(60)}" do
    result = Herb.parse(source)
    expect(described_class.print(result)).to eq(source)
  end
end
```

**4. Node-Type-Specific Tests**

Verify each of the 28 node types is handled. These overlap with round-trip tests but provide targeted coverage for edge cases:
- `HTMLCloseTagNode` with whitespace around tag name
- Boolean attributes (no `=` or value)
- Void elements (no close tag)
- ERB with trim markers (`-%>`, `<%-`)
- Nested ERB control flow (`if`/`elsif`/`else`/`end`)
- `ERBBeginNode` with `rescue`/`else`/`ensure`

## Implementation Order

1. **Scaffold gem** -- Create herb-printer directory with gemspec, Gemfile, Rakefile, Steepfile, binstubs, and boilerplate (following existing gems as template)
2. **PrintContext** -- No dependencies beyond the gem scaffold, unit-testable in isolation
3. **Base** -- Depends on PrintContext and Herb gem types
4. **IdentityPrinter** -- Depends on Base, validated by round-trip tests
5. **Wire up** -- Add `require_relative` entries to `printer.rb` entry point
6. **Tests** -- PrintContext specs, Base specs, IdentityPrinter round-trip specs

## Related Documentation

- [Overall Architecture](./architecture.md)
- [herb-core Design](./herb-core-design.md)
- [herb-format Design](./herb-format-design.md)
- [Configuration Specification](../requirements/config.md)
